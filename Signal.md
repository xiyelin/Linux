### 信号(Signal)
* [信号的例子](#信号的例子)
* [](#)
* [](#)
* [](#)

<br>

------------------------------------------------

### 信号的例子:

```c

		int main()
		{
			while(1);
			
			return;
		}
		
```

	在Linux环境下运行上述程序，这是一个死循环，当我们在键盘上按下 Ctrl+C 时，该进程就会终止。为什么会终止呢？
	 
	1. ⽤户输⼊命令,在Shell下启动⼀个前台进程。
		
	2. ⽤户按下Ctrl-C,这个键盘输⼊产⽣⼀个硬件中断。
		
	3. 如果CPU当前正在执⾏这个进程的代码,则该进程的⽤户空间代码暂停执⾏,CPU从⽤户态 切换到内核态处理硬件中断。
		
	4. 终端驱动程序将Ctrl-C解释成⼀个SIGINT信号,记在该进程的PCB中(也可以说发送了⼀ 个SIGINT信号给该进程)。
		
	5. 当某个时刻要从内核返回到该进程的⽤户空间代码继续执⾏之前,⾸先处理PCB中记录的信号,发现有⼀个SIGINT信号
	   待处理,⽽这个信号的默认处理动作是终⽌进程,所以直接终⽌进程⽽不再返回它的⽤户空间代码执⾏。
	 　　
<br>

	前台进程&后台进程：
<br>
	注意,Ctrl-C产⽣的信号只能发给前台进程。⼀个命令后⾯加个&可以放到后台运⾏,这样Shell不必等待进程结束就可以接受
	新的命令,启动新的进程。 Shell可以同时运⾏⼀个前台进程和任意多个后台进程,只有前台进程才能接到像Ctrl-C这种控制
	键产⽣的信号。前台进程在运⾏过程中⽤户随时可能按下Ctrl-C⽽产⽣⼀个信号,也就是说该进程的⽤户空间代码执⾏到任何
	地⽅都有可能收到SIGINT信号⽽终⽌,所以信号相对于进程的控制流 程来说是异步(Asynchronous)的。
	 　　
<br>

	如何查看系统的所有信号：  `Kill -l`

![image]()










	 　　
	 　　

