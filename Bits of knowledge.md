## 零碎知识

------------------------------------------------------------------------


###  1.fork()与vfork()的区别：

	(1)：vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进
	
	     一步动作，则会导致死锁。

	(2)：fork要拷贝父进程的进程环境；而vfork则不需要完全拷贝父进程的进程环境，在子进程没有调用exec和exit之前，子进程与父进程
	
	     共享进程环境，相当于线程的概念，此时父进程阻塞等待。


##	2.为什么会有vfork？
	
	    因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址空间，并且拷贝父进程的资源，而往往在子进程中会执行exec
		
	调用，这样，前面的拷贝工作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与父进程共享地址空间
	
	（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中运行，所以子进程不能进行写操作，并且在儿子霸占”着老子的房子时
	
	候，要委屈老子一下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相于儿子买了自己的房子了，这时候就相 于分家
	
	了。
	

##	3.特殊进程

	(1)： PID = 0 ；swapper 交换进程，系统进程，是内核的一部分，不执行磁盘上的程序，是调度进程；
	
	(2)： PID = 1 ；init 进程，用户继承，永远不会终止，启动系统，读取系统初始化的文件；
	
	(3)： PID = 2 ；pagedaemon 页精灵进程，系统进程，虚存系统的请页操作；

	孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收
	
			 养，并由init进程对它们完成状态收集工作。
	
	僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进
	
			 程描述符仍然保存在系统中。这种进程称之为僵死进程。

	僵尸进程危害场景：
		
			 例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的
			 
		 生命周期很短，但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，
		 
		 系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 严格地来说，僵死进程并不是问题的根源，
		 
		 罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的
		 
		 那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这
		 
		 些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进
		 
		 程 就能瞑目而去了。


###  4.Linux进程优先级

	 更改进程的 nice 值，范围是[-20, +19] ；优先级的值越小优先级越高，进程运行前使用 nice -n 值 ; 来更改优先级
	 
	 运行中的进程可以使用 renice 值 PID ; 来更改优先级。
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 



